{"pages":[],"posts":[{"title":"复试参考","text":"机器学习摸索过程，作为复试参考，记录一下好的参考博客 must be successful ！ 一、904学习参考 二、参考1.学习路线 如何在没有有效指导的情况下学习深度学习？ 2.参考书目 动手学深度学习 一个在线的电子书，全部要jupyter notebook，配有代码的形式 李航的统计学习（本地看） 3.参考视频1）统计学习 李航《统计学习方法》啃书指导 ​ 选取自B站，后面有更好的继续补充 2）机器学习（西瓜书） 机器学习西瓜书白话解读 附上一些算法的参考博客： 卷积神经网络知乎讲解​ 卷积神经网络CNN完全指南终极版（一） 卷积神经网络CNN完全指南终极版（二） 贝叶斯算法​ 带你理解朴素贝叶斯分类算法 ​ 如何理解贝叶斯定理？(要关注微信这个，不过讲的确实生动) ​ 如何通俗地理解“最大似然估计法”?(同上) 个人理解如何理解这个公式，我们来看这个图： ​ 我们所求的是：在A发生的情况下，他们的交集发生的概率； ​ 那么可以这么理解： ​ + 首先B事件发生有个概率P（B） ​ + B和A的交集概率P = B事件下A事件发生的概率 ​ + 那么将 B和A的交集概率P 除以 A发生的概率 = 发生A事件下B事件发生的概率 ​ 集成学习 手把手教你AdaBoost 一些概念： ​ 集成学习：通过构建并结合多个个体学习器 来完成学习任务； ​ 个体学习器： 通常由一个现有的学习算法（eg： 决策树，BP神经网络算法等）从训练数据产生； ​ 最终获得比单一学习器显著卓越的泛化性能 聚类","link":"/2022/03/07/%E5%A4%8D%E8%AF%95/"},{"title":"AI专业问题","text":"机器学习 1、损失函数1）定义在深度学习中, 损失函数是用来衡量模型参数的质量的函数, 衡量的方式是比较模型输出和真实输出的差异； 四种叫法： 2）应用地方分类任务中使用最多的是交叉熵损失函数； 多分类任务通常使用softmax将logits转换为概率的形式，所以多分类的交叉熵损失也叫做softmax损失 2、梯度下降用于优化深度学习 1）定义梯度下降简单来说就是一种寻找损失函数最小化的方法。 补：梯度的方向是函数增长速度最快的方向，那么梯度的负方向就是函数减少最快的方向； 梯度：在训练过程中损失函数对权重的偏导数就是损失函数在该位置点的梯度。 沿着负梯度方向移动，就可以到达损失函数底部，从而使损失函数最小化。这种利用损失函数的梯度迭代地寻找局部最小值的过程就是梯度下降的过程。 2）算法中遇到的问题 鞍点 动量算法、动量梯度下降算法 局部极小值 RMSProp（Root Mean Square Prop）算法将这些梯度按元素平方做指数加权移动平均 3、前、反向传播算法1)反向传播算法（BP算法）用途：​ 该方法与梯度下降算法相结合，对网络中所有权重计算损失函数的梯度； 然后利用梯度值更新权值以最小化损失函数； 定义：在网络的训练过程中经过前向传播后得到的最终结果跟训练样本的真实值总是存在一定误差，这个误差便是损失函数。 想要减小这个误差，就根据损失函数，从后往前，依次求各个参数的偏导，这就是反向传播（Back Propagation）。 计算方法：反向传播算法是利用链式法则进行梯度求解及权重更新的 对于复杂的函数，我们将其拆分为一系列的加减乘除等初等函数，通过链式法则完成复合函数的求导。 2)前向传播算法定义：指的是数据输入到神经网络中、逐层向前传输，一直运算到输出层为止 4、正则化1）解释设计机器学习算法时，不仅要考虑训练集上的误差，而且希望模型的在新样本上的泛化能力强； 许多机器学习算法都需要相关策略去减小测试误差，这个策略统称为正则化； 因为神经网络强大的表示能力经常遇到过拟合，所以需要不同形式的正则化策略。 通过对算法的修改减少泛华误差； 2）常见正则化的策略 L1 与 L2 正则化 在损失函数中增加一个正则项，由于这个正则化项，权重矩阵的值减小； 因为它假定具有更小权重矩阵的神经网络导致更简单的模型； 因此，它会在一定程度上减少过拟合。（L1和L2的不同就在于这个正则化项） 参数范数惩罚 提前停止 将一部分训练集作为验证集，当验证集的性能越来越差时或者不再提升时，则立即停止对模型的训练。 Dropout正则化 深度学习领域常见的正则化技术； 原理：在每个迭代过程中，随机选择某些节点删除前向和后向连接，因此每个迭代会有不同的节点导致不同的输出，这类似于集成方法，集成模型（发散思考：集成模型？）一般优于单一模型。 5、卷积神经网络1）解释CNN神经网络受人类视觉神经系统的启发，就比如当我们看到一个人脸时， 首先需要接收原始信号的输入（瞳孔摄入像素）； 接着做初步处理，大脑皮层分析确定边缘和方向； 然后抽象，判断眼前物体的形状，是圆形的； 接着进一步抽象，判断为人脸； 构成： 卷积层：负责提取图像局部特征 池化层：大幅降低参数量级（降维） 全连接层：类似人工神经网络的部分，输出想要的结果 2）卷积层提取输入图像的就不特征，卷积核可以提取图像中的边缘信息 多通道卷积：实际中的图像都是由多个通道组成的，这时候我们的卷积核需要拥有相同的channel数，每个卷积核channel与输入层对应的channel进行卷积，将最后的结果按位相加得到最终的Feature。 3）池化层 降低了后续网络层的输入维度，缩减模型大小，提高计算速度 提高了Feature Map 的鲁棒性，防止过拟合， 主要是对卷积层学习到的特征图进行下采样（subsampling）处理，两种方法： 最大池化：取窗口内的最大值作为输出 平均池化：取窗口内的所有值的均值进行输出 4）全连接层位于CNN的末端，经过卷积层的特征提取与池化层的降维后： 将特征图转换为一维向量送入到全连接层中进行分类或回归的操作； 5）常见的架构模型LeNet-5 AlexNet与LeNet-5相似，但也有显著区别 AlexNet包含8层变换，有5层卷积和2层全连接隐藏层，以及1个全连接输出层 AlexNet第一层中的卷积核形状是11×1111×11。第二层中的卷积核形状减小到5×55×5，之后全采用3×33×3。所有的池化层窗口大小为3×33×3、步幅为2的最大池化。（卷积核形状的改变和选择） AlexNet将sigmoid激活函数改成了ReLU激活函数，使计算更简单，网络更容易训练； AlexNet通过dropOut来控制全连接层的模型复杂度。 AlexNet引入了大量的图像增强，如翻转、裁剪和颜色变化，从而进一步扩大数据集来缓解过拟合。 VGGVGG可以看成是加深版的AlexNet，整个网络由卷积层和全连接层叠加而成； 和AlexNet不同的是，VGG中使用的都是小尺寸的卷积核(3×3)， 6、图像增强1）作用大规模数据集是深度卷积神经网络的前提； 例如，我们可以通过对图像的裁剪、平移、使得感兴趣的物体出现在不同的位置，减轻模型对物体位置的依赖性； 调整亮度、色彩等因素降低模型对色彩的敏感度。 通过图像增强，我们对训练图像做一系列随机变换，从而降低模型对某些属性的依赖，从而提高模型的泛化能力 2）常用方法几何变换+颜色变换 7、微调1）解释它是一个迁移学习。假如我们需要做一个椅子的分类任务，除了找好相关的数据集去训练以外，还有一种方法： 将源数据集学到的知识迁移到目标数据集上 该数据集训练的模型可以抽取较通用的图像特征，从而能够帮助识别边缘、纹理、形状和物体等 这些特征同样适用于识别椅子 做法就是，新建一个模型，它复制了源模型上除了输出层以外的其它层和参数，然后再在我们的目标数据集上，从头训练目标模型，重新训练输出层，而其余的参数都是基于模型的参数微调得到的。 当目标数据集远小于源数据集时，微调有助于提升模型的泛化能力。 8、目标检测常用的开源数据集：PASCAL VOC数据集 1）常用的评价指标 IoU（intersection over union，交并比） 目标检测算法中用来评价2个矩形框之间相似度的指标 mAP（Mean Average Precision） mAP是多个分类任务的AP的平均值，而AP（average precision）是PR曲线下的面积，所以在介绍mAP之前我们要先得到PR曲线。 2）NMS（非极大值抑制）顾名思义就是抑制不是极大值的元素。 如在目标检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。 但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。 在目标检测中，NMS的目的就是要去除冗余的检测框,保留最好的一个； 3）目标检测方法分类 two-stage的算法 先由算法生成一系列作为样本的候选框，再通过卷积神经网络进行样本分类。 主要通过一个卷积神经网络来完成目标检测过程，其提取的是CNN卷积特征；在训练过程中，主要训练候选区域的筛选和目标检测两部分。 特点： 网络的准确度高、速度相对较慢。 two-stages算法的代表是RCNN系列：R-CNN到Faster R-CNN网络 One-stage的算法 直接通过主干网络给出目标的类别和位置信息，没有使用候选区域的筛选网路， 特点：速度快，但是精度降低了很多。 one-stage算法的代表是： YOLO系列：YOLOv1、YOLOv2、YOLOv3、 SSD等 9、R-CNN1）解释在早期的Overfeat模型中，它使用固定宽、高的矩形框，在图像上滑动，并将扫描结果送入到神经网络中进行分类和回归； 但这样类似暴力穷举，需要非常大的计算力； 而R-CNN在这一点上做了改进，它不再使用暴力穷举的方法，而是使用候选区域的方法创建目标检测的区域来完成任务； 步骤： 候选区域生成：使用选择性搜索（Selective Search）的方法找出图片中可能存在目标的侯选区域 CNN网络提取特征：选取预训练卷积神经网络（AlexNet或VGG）用于进行特征提取。 目标分类：训练支持向量机（SVM）来辨别目标物体和背景，对每个类别，都要训练一个二元SVM。 目标定位：训练一个线性回归模型，为每个辨识到的物体生成更精确的边界框。 2）算法总结 训练阶段多、非常耗时 预测速度慢 占用磁盘空间大：有些5000张图像产生几百G的特征文件 数据的形状变化：候选区域要经过缩放来固定大小、无法保证目标的不变形 3）Fast R-CNN改进地方： 减少了重复计算、提高了速度 RCNN将分别将候选区域送入到神经网络中进行特征提取，由于候选区域有大量的重叠，会导致许多重复的计算； 而在Fast RCNN中，它将整张图输入到CNN中提取特征，然后再讲候选区域映射到特征图上，这样就避免了对图像区域进行重复处理； 不需要额外的空间 RCNN中需要将提取到的特征保存下来，用于为每个类训练单独的SVM分类器和边框回归器； FastRCNN中，将类别判断和回归统一使用CNN实现，不需要额外的空间存储特征； 不直接对候选区域进行缩放 RCNN中需要对候选区域进行缩放送入CNN中进行特征提取，在Fast-RCNN中使用ROIpooling的方法进行尺寸的调整。 步骤是： 1、候选区域生成：使用选择性搜索（Selective Search）的方法找出图片中可能存在目标的侯选区域，只需要候选区域的位置信息 2、CNN网络特征提取：将整张图像输入到CNN网络中，得到整副图的特征图，并将上一步获取的候选区域位置从原图映射到该特征图上 3、ROIPooling: 对于每个特征图上候选框，RoI pooling层从特征图中提取固定长度的特征向量每个特征向量被送入一系列全连接（fc）层中。 4、目标检测：分两部分完成，一个输出各类别加上1个背景类别的Softmax概率估计，另一个为各类别的每一个类别输出四个实数值，来确定目标的位置信息。 4）Faster R-CNNFaster R-CNN的流程与Fast R-CNN的区别不是很大; 重要的改进: 使用RPN网络来替代选择性搜索获取候选区域， 10、yolo系列batch normalization批标准化有助于解决反向传播过程中的梯度消失和梯度爆炸问题，降低对一些超参数的敏感性，并且每个batch分别进行归一化的时候，起到了一定的正则化效果，从而能够获得更好的收敛速度和收敛效果。 11、支持向量机二分类的本质就是在数据的特征空间内，寻找间距最大的超平面，将数据划分为两类，以实现区分。 SVM还包括核技巧，这让它成为实质上的非线性分类器； SVM的学习策略就是间隔最大化，学习算法就是求解凸二次规划的最优化算法； 1）何为线性可分在二维空间上，两类点被一条直线完全分开叫做线性可分。 2）何为支持向量 SVM最优化问题，就是找到各类样本到点到超平面的距离最远，即：找到最大间隔超平面 3）软间隔问题： 实际应用中，完全线性可分的样本是很少的，很多时候是不能够完全线性可分的样本； 于是我们就引入了软间隔，我们允许个别样本点出现在间隔带里 4）核函数先前考虑的都是样本的完全线性可分或者大部分样本点的线性可分 但如果样本点是线性不可分的 就需要将不可分样本映射到高维空间，让样本点在高维空间线性可分； 总结: 对于在有限维度向量空间中线性不可分的样本，我们将其映射到更高维度的向量空间里，再通过间隔最大化的方式，学习得到支持向量机，就是非线性 SVM。 5）优缺点 有严格的数学理论支持，可解释性强，不依靠统计方法，从而简化了通常的分类和回归问题； 能找出对任务至关重要的关键样本（即：支持向量）； 采用核技巧之后，可以处理非线性分类/回归任务； 最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。 6）参考博客 【机器学习】支持向量机 SVM（非常详细） 12、决策树1）解释决策树是一种机器学习的方法，它是一种十分常用的分类方法； 它是一种树形结构： 每个内部节点表示一个属性上的判断 每个分支代表判断结果 每个叶节点代表最终的分类结果 它通过给定的样本和标签，通过学习这些样本得到一个决策树，通过这个决策树能够对新的数据给出正确的分类； 我们在做决策树的时候，会经历两个阶段：构造和剪枝。 2）构造构造就是生成一棵完整的决策树。简单来说，构造的过程就是选择什么属性作为节点的过程 3）剪枝剪枝就是给决策树瘦身，这一步想实现的目标就是，不需要太多的判断，同样可以得到不错的结果。之所以这么做，是为了防止“过拟合”（Overfitting）现象的发生。 剪枝方法 预剪枝 在决策树构造时就进行剪枝。 方法是，在构造的过程中对节点进行评估， ​ if 对某个节点进行划分， ​ 在验证集中不能带来准确性的提升，那么对这个节点进行划分就没有意义， 这时就会把当前节点作为叶节点，不对其进行划分。 后剪枝 在生成决策树之后再进行剪枝。 通常会从决策树的叶节点开始，逐层向上对每个节点进行评估。 如果剪掉这个节点子树，与保留该节点子树在分类准确性上差别不大，或者剪掉该节点子树，能在验证集中带来准确性的提升，那么就可以把该节点子树进行剪枝。 方法是：用这个节点子树的叶子节点来替代该节点，类标记为这个节点子树中最频繁的那个类。 4）参考 决策树(Decision Tree)：通俗易懂之介绍 决策树 13、聚类1）解释按照某个特定标准(如距离准则)把一个数据集分割成不同的类或簇， 使得同一个簇内的数据对象的相似性尽可能大， 同时不在同一个簇中的数据对象的差异性也尽可能地大。 目标 即聚类后同一类的数据尽可能聚集到一起，不同数据尽量分离。 2）聚类和分类的区别聚类是无监督学习，它没有 lables ； Clustering (聚类) 简单地说就是把相似的东西分到一组，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起。 一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，因此 clustering 通常并不需要使用训练数据进行学习，这在Machine Learning中被称作unsupervised learning (无监督学习)。 Classification (分类) 对于一个classifier，通常需要你告诉它“这个东西被分为某某类”这样一些例子，理想情况下，一个 classifier 会从它得到的训练集中进行“学习”，从而具备对未知数据进行分类的能力，这种提供训练数据的过程通常叫做supervised learning (监督学习)。 3）算法分类 基于划分 思想： 有一堆散点需要聚类，我们想要达到的效果：类内的点都足够近，类间的点都足够远 首先，确定这堆散点聚成几类； 然后，挑选几个点作为初试中心点； 再然后，给数据点做迭代重置； 主要算法： k-means、k-medoids、k-modes、k-medians、kernel k-means等算法。 基于层次 合并的层次聚类 和 分裂的层次聚类； 前者是一种自底向上的层次聚类算法，从最底层开始，每一次通过合并最相似的聚类，来形成上一层次中的聚类；当全部数据点都合并到一个聚类的时候停止或者达到某个终止条件而结束； 后者是采用自底向下的方法，从一个包含全部数据点的聚类开始，然后分裂为子聚类，递归的继续往下分裂；直到出现只包含一个数据点的单节点聚类出现，即每个聚类中仅包含一个数据点。 主要算法 BIRCH算法、CURE算法、CHAMELEON算法 基于密度 K-means解决不了的不规则形状的聚类，于是就有了基于密度的方法。 该方法同时对噪声数据的处理比较好，原理： 定义一个圆，设置好最大半价，以及一个圆圈最少容纳几个点 14、降维与度量学习参考- 周志华《Machine Learning》学习笔记（12）–降维与度量学习 1）维数灾难、低维嵌入维数灾难： 样本的特征数称为维数，高维空间时，数据样本将变得十分稀疏，而此时满足密采样样本的数目将会是一个天文数字，计算距离变得十分复杂； 事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍，被称为”维数灾难”； 解决维数灾难 降维，也称“维数约简”； 通过某种数学变换将原始高维空间 转换为 一个“低维子空间”，这个子空间内，样本密度大幅提高，距离计算也变得更为容易； 为什么能降维 很多时候，人们观测或收集到的数据样本虽然是高维的，但学习任务密切相关的也许仅是某个低维分布，即高维空间中的一个低维嵌入。 对高位数据降维还能在一定程度上达到提炼低维优质属性或降噪的效果。 2）主成分分析（PCA）最常用的的降维方法； PCA：通过一个线性变换，将原始空间中的样本投影到新的低维空间中。 简单来说，采用一组新的基来表示样本点，其中每一个基向量都是原来基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的 不妨先考虑这样一个问题:对于正交属性空间中 如何用一个超平面(直线的高维推广)对所有样本进行恰当的表达? 容易想到，若存在这样的超平面，那么它大概应具有这样的性质: 最近重构性：样本点到这个超平面的距离都足够近; 最大可分性：样本点在这个超平面上的投影能尽可能分开. 3）核化线性降维SVM在处理非线性可分时，通过引入核函数将样本投影到高维特征空间，接着在高维空间再对样本点使用超平面划分， 核函数：先将样本映射到高维空间，再在高维空间中使用线性降维的方法。 核化主成分分析（KPCA）:即空间中的任一向量，都可以由该空间中的所有样本线性表示 4）流形学习流形学习（manifold learning）是一种借助拓扑流形概念的降维方法，流形是指在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。 这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种“邻域保持”的思想。 等度量映射（Isomap）试图在降维前后保持邻域内样本之间的距离， 高维空间中的直线距离是具有误导性的，有时候高维空间的直线距离在低维空间中是不可达到。因此利用流行在局部上与欧式空间同胚的性质，可以使用近邻距离来逼近样本距离； 而局部线性嵌入（LLE）则是保持邻域内样本之间的线性关系 5）度量学习我们通常解决维数灾难，即在高维空间进行机器学习任务遇到样本稀疏、距离难计算等诸多的问题； 因此前面讨论的降维方法都试图将原空间投影到一个合适的低维空间中，接着在低维空间进行学习任务从而产生较好的性能。 事实上，不管高维空间还是低维空间都潜在对应着一个距离度量，那可不可以直接学习出一个距离度量来等效降维呢？例如：咋们就按照降维后的方式来进行距离的计算，这便是度量学习的初衷。 6）总结降维是将原高维空间嵌入到一个合适的低维子空间中，接着在低维空间中进行学习任务；度量学习则是试图去学习出一个距离度量来等效降维的效果，两者都是为了解决维数灾难带来的诸多问题。 15、集成学习1）基本概念2）Boosting3）随机森林","link":"/2022/03/15/AI%E4%B8%93%E4%B8%9A/"},{"title":"复式参考书签","text":"作为复试的摸索过程，浅浅记录一下 ! 一、英文问答1、考研复试_英语面试_问与答2、考研浙大计算机复试英语问答资料3、计算机专业 英语复试专业问题准备（1）4、复试口语常见话题整理以及华师18 19年topic5、计算机考研复试面试问题总结和回答二、文献翻译1、计算机考研复试_令人头大的_英文文献翻译2、文献翻译练习方法三、专业知识1、计算机考研复试问题汇总（408+计算机前言知识）2、复试随笔-前沿知识 另一篇博客-各类专业知识 3、计算机网络篇 TCP 三次握手和四次挥手 Http与Https的区别、TCP的三次握手四次挥手、TCP与UDP的区别 一文搞定所有计算机网络面试题 计算机网络下 4、数据结构篇 数据结构篇（下） 5、操作系统篇 操作系统常见面试题2021最新版","link":"/2022/03/13/%E5%A4%8D%E5%BC%8F%E5%8F%82%E8%80%83%E4%B9%A6%E7%AD%BE/"},{"title":"clash Tun模式实现设备共享上网","text":"ubuntu下使用 clash + Tun模式 实现设备共享 Science 上网 突发奇想，为了更加的方便，能够在床上玩手机，所以做个记录！！ 一、前言因为没啥流量，所以通过插入学校网线的电脑开启热点给手机用，因为习惯用谷歌，所以需要科学 Internet ； 就想着先前配置过clash，就想着用clash tun 实现局域网的设备共享代理； 准备工作 系统：Ubuntu 20.04，能上网，能开热点 不限系统的手机，能连热点就行 最终效果电脑开启热点，只要连入热点的设备，都能够进行 翻Wall； 二、Tun模式何为clash，Tun模式1）Clash 是由Dreamacro 开发的，是一个使用Go 开发的、基于规则的隧道，在中国大陆地区可用于突破防火长城的限制。 2）对于不遵循系统代理的软件，TUN 模式可以接管其流量并交由 CFW 处理，在 Windows 中，TUN 模式性能比 TAP 模式好 Tun 模式可以通过新建一个 Tun 虚拟网卡接受操作系统的三层流量，从而拓展 Clash 入口（inbound) 转发能力。 Tun 模式有以下潜在的优点： 提升 Clash 处理 UDP 的能力 从Inbound发回三层流量时，IP 源地址可由 Clash 控制 因此在使用 socks5或shadowsoks协议时，可以表达 socks5/ss 协议发回的 UDP 流量中不同的源IP地址 因此，有可能通过 OutBound 代理实现 STUN 因此，对在代理条件下很多游戏的体验会有提升 可以劫持任何三层流量，Clash 可以在任何IP地址和任何端口提供某些服务，非常灵活 因而可以实现 DNS 劫持 可以与操作系统的网络栈结合，利用 iptables 等组件的能力 实现Tun 模式的核心问题有两个： 使用操作系统的 API 建立 Tun NIC（Network Interface Card），得到 IP Packet 由三层IP Packet 重组传输层 TCP stream / UDP Packet，交由 Clash 进行转发 其中，创建 NIC 并得到三层网络包可以由一系列系统调用实现。而由三层流量重组四层流量需要用户态网络栈。因为 Clash 使用 Go 语言，PR393 使用了 gvisor 的网络栈。gvisor 的网络栈前身是 netstack 。 三、配置过程1）Clash配置、安装参考本人博客 2）编辑配置文件 配置文件参考： 附上配置代码： 123456789101112131415mixin: # object dns: enable: true enhanced-mode: fake-ip nameserver: - 114.114.114.114 # 真实请求DNS，可多设置几个 - 8.8.8.8 - 114.114.114.114 tun: enable: true stack: system # 或 gvisor dns-hijack: # DNS劫持设置为系统DNS - 1.0.0.1:53 # 请勿更改 auto-route: true auto-detect-interface: true 注意这几个地方 PC端clash配置就完毕 3）连接首先查看自己PC端 IP ，因为相当于把自己的linux主机作为网关，进行流量的转发； 注意自己`IPv4 ， 子网掩码 移动端设备设置 DNS也设为主机地址，来进行解析 然后就可以冲浪了","link":"/2022/03/11/clash-Tun%E6%A8%A1%E5%BC%8F/"},{"title":"leetcode-剑指offer","text":"记一下Leetcode题踩的坑，码代码能力很久不码就很容易忘掉 最近又在用python写毕设，就决定用python刷题 2022-03-08剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路 将二维矩阵旋转成为一个二叉排序树，然后开始从右上角遍历； 根据 target 与 martix[i][j] 比较，对 i 和 j 进行增减 12345678910111213141516171819class Solution(object): def findNumberIn2DArray(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; i,j = 0,len(matrix[0])-1 while i&gt;=0 and j&lt;len(matrix[0]): if matrix[i][j] &lt; target: i += 1 elif matrix[i][j] &gt; target: j -= 1 else: return True return False 报错信息：IndexError: list index out of range 异常是 列表发生越界， 解决一开始还打印了每个步骤的值，发现结束是没啥问题的 后来想了很久，那可能是一开始出了问题？ 因为我们这里从右上角开始遍历比较，做的是减法 那么如果一开始二维数组只有一个元素呢？ —- 那么就会导致越界 我们看这里： 123456789101112131415二维数组：【3】，target = 5-------------i = 0,j = 0进入while循环 if 不满足； 进入elif： j-1 更新值 j = 0-1 = -1----------第二轮i = 0 ,j = -1(仍然满足条件)但接下来判断就会出现越界 这就是错误所在！ 而从左下角开始就刚好规避了这个问题，算是一个巧的地方 相当于一个确定左下，一个框定右上，所以自然不会越界。 同时还需注意 len(martix[0])：列数量 len(martix) ：行数量 再遇到[]会报错","link":"/2022/03/08/leetcode-record/"},{"title":"ubuntu 安装Clash 科学上网","text":"本来用的是V2rayA，奈何每次白嫖节点都需要手动测试很麻烦，所以就想换clash 奈何这类软件对linux支持不是很好，折腾一下 Science Internet一、Clash与V2Ray的区别 V2ray ​ v2ray 目前没有自动选择节点的功能，在每次使用时我得先去测试这个节点能不能用，够不够快。但是它上手快，稳定性高，支持大部分的主流协议，更新快，也支持机场订阅链接等，能满足日常科学上网的基本需求，适合新手小白。 Clash ​ 相比与V2ray , 对于使用免费节点的来说，clash是更好的选择，它可以自己选择节点，不用自己一个个去测试。 二、ubuntu 20.04 下部署clash（失败）我之前在ubuntu下用的是V2rayA ，界面如下： 每当我需要更换节点时候，我的一个个去 选择-&gt;断开-&gt;测试，……，选择-&gt;断开-&gt;测试，既麻烦，又繁琐。 话不多说，开始正题： （1）下载地址 GitHub 地址：Clash Releases下载：https://github.com/Dreamacro/clash/releases x86-64位的选择这个linux-amd64的，这个应该不用多说 （2）解压缩打开文件目录，进行解压缩，会得到一个执行文件 右键properties——&gt;permissions,勾选 或者命令： chmod +x clash-linux-amd64 运行：./clash-linux-amd64 貌似出错了,去了Gituhb 上的issue看了看：[Bug] Start DNS server error: missing port in address 有说版本问题的，有说不影响使用的，算了先不管 （3）配置clash初始化执行 clash 会默认在 ~/.config/clash/ 目录下生成配置文件和全球IP地址库：config.yaml 和 Country.mmdb 12#看是否有配置文件ls ~/.config/clash/ 可以看看配置文件config.yaml,只有端口号 我们把官网的配置文件复制过来：配置文件地址 编辑使用gedit也行，vim也行，看个人习惯. 复制过来保存就行 12345# 切换到目录cd ~/.config/clash/#编辑配置文件sudo gedit config.yaml 回到之前目录，再次执行clash 1./clash-linux-amd64 报错了，简直无语 （4）换种方法我们仍然回到这个目录 123# 下载Country.mmdb wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb 这里我准备好了config.yaml,我用v2ray订阅转的clash配置文件 也可也输入如下命令，去服务商给的网址下载，本地保存为config.yaml 123# 下载config.yaml [clash订阅链接]自己去找wget -O config.yaml [clash订阅链接] 指定当前目录运行 -d . 12./clash-linux-amd64 -d . 打开clash-web控制台：http://clash.razord.top/#/proxies 会发现有3个参数，前面2个保持默认，我们进行密码设置，打开config.yaml,直接复制进去就好，密码设置：123456(随意) 1234# Secret for the RESTful API (optional)# Authenticate by spedifying HTTP header `Authorization: Bearer ${secret}`# ALWAYS set a secret if RESTful API is listening on 0.0.0.0secret: &quot;123456&quot; 然后登不进去，失败告终！！有些问题，搜索了很久，没啥结果，还是换个版本，曲线救国。 三、ubuntu 20.04 下部署clash（成功）一开始想装失败了，于是换个版本：Clash for windows，据说这个目前已经支持了linux版本，还支持用 UI 界面方便随时切换。 这个 Clash For Windows 的名字乍一看有点歧义，实际上是全平台的，不是 Windows 专属的。 优点如前文所述： 支持自动选择节点，可以根据延迟自动选择，也可以根据规则 支持本地编辑规则 支持查看当前订阅的流量等信息 前面试图装的clash还只能支持命令行，需要有点功底才行，话不多说，进入正题： （1）下载地址​ Github地址：Clash for Windows Releases下载 ​ 镜像地址：https://down.gtk.pw/proxy/linux ​ （2）然后解压缩： ​ 该目录下进入终端（主要是双击点不开cfw）： ./cfw （2）官方使用手册地址（3）问题 问题1： clash端口号一直为0 手动设置为端口7890 问题2：一切都按照配置好了，为什么还是没有网络？ 还需要安装 iproute2，然后重启 1sudo apt install nftables iproute2 参考博客：https://bbs.deepin.org/en/post/229552?offset=1&amp;limit=20#reback_title 发现状态一直未激活，看了issue发现是bug，后面已经修复： 汉化补丁下载 然后重新启动cfw，发现已激活： 最后去谷歌商店下载： Proxy SwitchyOmega 设置代理，然后选中： 刷新网页，看是否有请求 不知道为啥，框出来的地方一直是0，可能是bug吧，但并不影响使用","link":"/2022/03/07/Science%20Internet/"},{"title":"我的测试","text":"月是人间散客，亦是人间清乐 问韶华，一杯真假，爱梦难懂，只是负韶华，一杯人间错，问十里情海，花红花火，只是系别错，柔情懂，只是人间错，问梨花，思念无暇，东风起，奈何泪，十里相思错，问人间一别，从此南柯一梦。","link":"/2022/03/06/mytest/"},{"title":"Ubuntu 20.04LTS 搜狗输入法不显示图标","text":"使用ubuntu以来，搜狗输入法经常失灵，所以就记录一下这次操作过程 以便往后照着操作！ 原来的输入法设置就是如上图所示，之前也好像可以用，但我更新了一下依赖和包以后就不能用了，实在不理解。 我不知道为什么有时我不能使用搜狗拼音作为我的输入法。我在谷歌搜索了一大堆，但没有什么有用的； 情况大致如此：搜狗输入法无法启动，托盘处不显示图标，哪怕显示我选择了搜狗输入法，但仍然不显示图标； 所以我想是不是fcitx出了问题，终端 重启fcitx，发现图标显示恢复正常，但当我把终端关掉以后，又变成键盘的样子。 1fcitx restart 最后，我将搜狗输入法移动到上面去后，就可以使用了，但也只有光标出现在输入的地方才能进行搜狗输入，否则仍然显示键盘图标 总感觉问题还没解决，后续再看看……","link":"/2022/03/06/Ubuntu%2020.04LTS%20%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E6%A0%87/"},{"title":"ubuntu 部署docker容器","text":"了解一下docker，并且试着把之前失败的clash，重新装一下 Docker 是什么？ 我们常说的“Docker”，指的是容器化技术，用于支持创建和使用 Linux容器； 一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows机器上； 容器是完全使用沙箱机制，相互之间不会有任何接口。几乎没有性能开销，可以很容易地在机器和数据中心运行。 为什么用Docker容器技术之前，火热的技术是虚拟机技术，而其最典型的代表就是 VMWare和OpenStack； 而Docker技术走热的原因，说白了就是“轻”，一种轻量化虚拟技术； Docker的优缺点1.启动时间虚拟机虽然可以隔离出很多子电脑，但是占用空间大，启动慢； 而容器技术不需要虚拟整个操作系统，只需要虚拟一个小规模的环境，启动速度很快，几秒就能完成。 2.性能Docker容器共享宿主机内核，系统级虚拟化，占用资源少，没有Hypervisor层开销，性能基本接近物理机； 虚拟机需要Hypervisor层支持，具有完整的GuestOS（虚拟操作系统），虚拟化开销大，因而降低性能，没有容器性能好 3.占用开销此外，它占的空间很小，容器只需要MB级甚至KB级。 虚拟机一般要几GB到几十GB的空间 4.安全性Docker容器由于共享宿主机内核，只是进程级隔离，因此隔离性和稳定性不如虚拟机，Docker容器具有一定权限访问宿主机内核，存在一定安全隐患； Docker的三大核心 镜像（Image） 容器（Container） 仓库（Repository） Docker镜像，就像一个完整的文件包，它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器的实质是进程，它运行与独属于自己的命名空间，类似在一个独立于宿主下的系统上操作（相当于小虚拟机），这种特性使得容器封装的应用比直接在宿主运行更加安全。 镜像构建完成后，可以很容易的在当前宿主机上运行；但是如果需要在其他服务器上使用这个镜像呢？ 这时候就需要仓库，它的工作就是用来存放、发放镜像的——也就是所说的“Docker Registry ” 简而言之：一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 Ubuntu20.04下部署Docker环境1.安装建议直接看官方文档 卸载旧版本如果之前有安装过，建议清楚一下配置 123sudo apt-get remove dockersudo apt-get remove docker-enginesudo apt-get remove docker.io 脚本安装用APT安装比较麻烦，还要证书啥的； 而在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装： 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 我们建立一个文件夹，执行第一条命令下载脚本 然后运行脚本，并指定镜像，安装成功 建立用户组默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1sudo groupadd docker 将当前用户加入 docker 组： 1sudo usermod -aG docker $USER 测试是否安装成功1docker run --rm hello-world 常用命令启动Docker 12sudo systemctl enable dockersudo systemctl start docker 关闭Docker 1sudo systemctl stop docker Docker部署clash准备配置文件：config.yaml 部署Clash核心Clash 有官方的 Docker 部署教程，以及完整的配置项说明文档。有兴趣深入了解的可以看看，咱们简单粗暴点略过 docker-compose 直接上命令 进到我们新建的文件夹： 12sudo docker run -d --name=clash -v &quot;$PWD/config.yaml:/root/.config/clash/config.yaml&quot; -p &quot;7890:7890&quot; -p &quot;9090:9090&quot; --restart=unless-stopped dreamacro/clash 图形化控制台1.在线控制台http://yacd.haishan.me/ 2.本地部署1git clone -b gh-pages https://github.com/haishanh/yacd.git 这是 yacd 作者编译好的版本，克隆下来之后用浏览器访问其中的 index.html 即可 3.docker 部署Run: docker run -p 1234:80 -d –rm haishanh/yacd 4.一点小问题本地部署yacd后，点击index.html，发现网页是空白的，按F12查看报错信息： 发现是因为谷歌浏览器不能通过本地文件的路径：file://XXX 去访问，只能通过http://xxx 的形式访问，所以报错 然后我们直接通过下面的URL：http://127.0.0.1:8887/访问就行了； 不过还是在线访问简单！！！","link":"/2022/03/06/ubuntu-docker/"},{"title":"Ubuntu 20.04LTS 文件夹图标丢失","text":"之前在安装环境和依赖的时候，不知道用了什么操作，文件夹图标就消失了？？？ 我寻思着我也没做啥，文件夹图标就丢失了，一直用命令行进行文件操作挺麻烦的。 运行命令： sudo apt install gnome-shell-extension-desktop-icons 然后重新登入、登出，就能在应用列表看到了 最后右键Add to Favorites就行了","link":"/2022/03/06/Ubuntu%2020.04LTS%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%9B%BE%E6%A0%87%E4%B8%A2%E5%A4%B1/"},{"title":"Blog部署","text":"记录一下 hexo-theme-amazing 配置历程 持续更新 ing………… 1.背景修改 问题描述 ​ 原来的背景很花，不是很喜欢，尤其是在深色模式下，加载会出现蓝蓝花花的显示，对于我个人来说不是很好 类似这样： ​ 解决方法：​ 去 hexo-theme-amazing/include/style/mystyle/base.styl文件修改： 对比我的参考： ​ ​ 删掉这个部分就好了 ​ 效果预览 ​ ​ 这样看起来就清爽很多了 2.文章折叠 问题描述 打开首页每一篇博文都是完整的展露出来，非常不适合平时的浏览习惯，类似下面这样，一展到底…… 解决办法 简单来讲就是在你撰写的文档里面添加： 类似下面这样 然后看看预览效果： 确实折叠了，但好像不咋的好看，但做法就是如此 如果写博文的，可以自己放一张图进去？ 预览效果 3.博客评论数更新 问题描述 注意这个地方的数据不是真实的 解决办法 1）新建放评论的仓库 一定为公有的！！ 然后出现如下页面； 我们先不用管，直接点击个人头像来到个人设置界面： (2)新建APP 域名前面貌似要加 http(s)，不然会报错 2）生成客户端秘钥 完成好前面步骤后，会来到如下页面 我们点击生成Client secrets，输入密码后，就能看到生成的了 （4）配置文件修改 改成我们刚刚修改的就好了 4.改中文根目录下，找到配置文件 将 en -&gt; zh-CN 就行了 · 123# 清除缓存、部署就OKhexo cleanhexo g -d 效果预览 可以看到些许地方都变成中文了，但是顶部导航栏仍然是中文，大家可以直接去主题的 config.yml 文件，手动翻译一下就好了吧 查阅了issues，作者说这里确实要手动改！！！ 5.yaml front matter1）快速开始Front-matter 是且只能是文件最上方以 --- 分隔的区域，用于指定个别文件的变量 for example，这是新建的md文档 我们在首行输入 --- -&gt; 回车； 然后就会出现了书写区域 2）参数解释以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 详细的就不说了，以后有好的参考博客，我会贴出来的 参考一：front-matter使用详解 参考二：hexo博客front-matter格式 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 3）使用效果12345678910111213141516---title: 标题date: 2022-03-05 20:00:00summary: # 文章摘要toc: truemathjax: truetop: truecover: trueimg: 'https://img-blog.csdnimg.cn/20200309120551356.png' # 设置文章背景图，设置为外链图片，访问快tags: - 标签1 - 标签2categories: - testauthor: Tlo_oh--- 我们将它部署到博客，本地预览效果 从这个效果和对比，应该可以看出哪里改动了 所以根据我个人的需要，应该这样写： 4）总结这个 img 没啥用首先，每个主题的front-matter不一样，我看了好多，建议看作者的主题配置参考：Icarus (ppoffice.github.io) 效果如下：（这里是本地引用，也可以引用图床的外链啊） 然后其余几个数学公式、置顶啥的根据需要吧； 往后的博客就按照这个格式来发布，相对来说还直观一点, 如果再浏览长篇博客的时候，可以加上toc： ture,这样在盘边就会生成目录，方便浏览 这里放一个参考：参考1 参考2 里面有讲到用插件，这个之后再折腾吧…… 6.widgets增减为了简化主页的展示，可以对这些模块进行删减，或者移动到右边去； 因为我这是刚刚开始，所以有一些暂时还没什么用 我们来到主题目录下的 _config.yml 每个 - 开始的都是一个模块，我们根据需要注释掉就行 我这里注释的是 链接 和 评论 部分（这里 - 也要一起注释，不然编译会报错） 12# 部署到服务器hexo s -d 观看效果 7.评论数（ing）F12检查 报错这个 据说华东节点用不了，于是我又改用国际版的 仍然报错 8.SEO优化SEO（搜索引擎优化）是一种通过优化网站内容来获得搜索引擎的自然搜索结果排名的实践。 简单来说就是推广，首先得让搜索引擎收录自己的网站，这样别人才能通过关键词搜索到； 刚建站的时候是没有搜索引擎收录我们的网站的。可以在如在百度搜索引擎中输入site:域名来查看一下。 百度SEO1）登录百度站长平台添加网站 2）填写信息、选择验证方式 个人感觉HTML比较简单，当然下面都有很详细的具体方法： 我的博客仓库部署在github上 3）提交资源在博客文件的根目录下执行如下命令，自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎 12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 然后部署到github 1hexo g -d 然后可以看到目录下生成了几个文件 提交地址等待状态就好了，据说百度收录比较慢，得等个十天半个月…… Google SEO1）去Google站点地图进入Google站点地图，提交网站和sitemap.xml，就可以了。 有域名直接访问这里：Google Search Console； 不出意外的话一天内Google就能收录你的网站了。不过访问Google需要 楼梯 才能去外面的世界； 然后生成一串代码： 2）添加域名解析记录注意到这里的要求： 登录到您的域名提供商网站（比如我是阿里云买的域名，就去阿里云） 将下面的 TXT 记录复制到你的的DNS配置中 然后点击解析，添加记录 注意这里选择TXT，其余默认就好了 3）验证结果回到之前谷歌的界面，点击验证按钮进行验证，如果显示绿色的结果，代表验证成功。 如果不成功 可以等待一段时间，DNS解析需要一段时间 或者，根据上方步骤重新检查验证流程。","link":"/2022/03/05/Blog%E9%83%A8%E7%BD%B2/"},{"title":"数字图像处理","text":"粗略记录一下，用于处理计算机视觉的图像处理代码，具体的原理就不再赘述了后续也会持续更新…… 1. opencv 读取图片123456789101112import cv2 as cv # 导入open cv# 读取图片路径img = cv.imread(&quot;/home/tlooh/下载/Data/tmp/1&quot;,cv.IMREAD_GRAYSCALE)# 显示图片，picture为显示窗口的title，第二个img为图片路径cv.imshow(&quot;picture&quot;,img)# 参数=0: （也可以是小于0的数值）一直显示，不会有返回值 # 若在键盘上按下一个键即会消失 ，则会返回一个按键对应的ascii码值 # 参数&gt;0:显示多少毫秒 超过这个指定时间则返回-1cv.waitKey(1000)# 摧毁所有窗口cv.destroyAllWindows() cv.IMREAD_GRAYSCALE 这个参数应该是灰度化，更多的的灰度处理方式可以看这里：参考博客 12345678img = cv.imread(&quot;/home/tlooh/下载/Data/tmp/1&quot;,cv.IMREAD_GRAYSCALE)灰度化的参数：IMREAD_GRAYSCALE；0彩色：1； 2. 直方图均衡化1）参考博客很详细的一篇参考博客：OpenCV计算机视觉学习（9）——图像直方图 &amp; 直方图均衡化 2）代码以及效果12345678910111213141516171819202122232425262728293031import cv2 as cv# 读取图像，并灰度化img = cv.imread(&quot;/home/tlooh/下载/Data/tmp/1&quot;,cv.IMREAD_GRAYSCALE)# 调用函数cv.calcHist() 绘制直方图img_hist = cv.calcHist([img],[0],None,[256],[0,256])# 调用函数 cv.equalizeHist() 实现直方图均衡化result_img = cv.equalizeHist(img)# 显示两幅图像对比cv.imshow('before',img)cv.imshow('after',result_img)cv.waitKey(5000)cv.destroyAllWindows()# 使用matplotlib进行直方图绘制import matplotlib.pyplot as plt# 前后两副直方图对比plt.hist(img.ravel(),256)plt.show()plt.hist(result_img.ravel(),256)plt.show() 关于cv.calcHist() 函数参数意义： 运行效果（效果其实挺明显的）： 直方图对比，可以看到原来灰度值频率很低的地方得到了填充，也就是所谓的均衡化； 想要追求效果明显的化，可以找一下局部过曝，或者亮度不均匀的图片进行测试，效果会更加明细。 3）、彩色直方图均衡化（补）我们知道通常的彩色图像包含多个通道，例如R，G，B三个 channel，上面演示了如何将灰度直方图均衡化； 那么我们是不是可以通过以下步骤实现彩色图像的均衡化呢？ 对彩色图像各个通道分别进行单通道均衡化 最后合并所有通道即可 cv2.mergecv2.split 代码 1234567891011121314151617def histColorimg(img): # 将图像分割成 B,G,R 3个通道 B,G,R = cv.split(img) # 图片显示 cv.imshow('img',img) cv.imshow('R',R) cv.imshow('G',G) cv.imshow('B',B) cv.waitKey(300000) cv.destroyAllWindows()img = cv.imread(&quot;/home/tlooh/下载/Data/tmp/4.png&quot;,1) histColorimg(img) 效果 几个点 为什么是按B、G、R读取？ 因为Open CV 默认就是按这个通道顺序读取的图片，这里要注意！！！ 为什么得到的还是不同的灰度图呢？不是分离R，G，B了吗？ 这是因为再用imshow()时候，是把图像的R，G，B三个通道的值都变为R的值，所以图像的颜色三通道值为（R，R，R），其它通道同理 1.通过索引拆分通道123&gt;img[:,:,0] # 获取img的B通道&gt;img[:,:,1] # 获取img的G通道&gt;img[:,:,2] # 获取img的R通道 2、代码示例分别展示一张保留G和R通道的图像、一张只保留R通道的图像 1234567891011121314151617181920212223&gt;def histColorimg(img): # 将图像分割成 B,G,R 3个通道 B,G,R = cv.split(img) # 图片显示 cv.imshow('img',img) # B通道置0 img[:,:,0] = 0 cv.imshow('b0GR',img) # G通道置为0 img[:,:,1] = 0 cv.imshow('b0g0R',img) cv.waitKey(30000) cv.destroyAllWindows()&gt;img = cv.imread(&quot;/home/tlooh/下载/Data/tmp/5.png&quot;,1) &gt;histColorimg(img) 3、效果 3. 双线性插值12345tf.gfile.FastGFile(path,decodestyle) 函数功能：实现对图片的读取。 函数参数： (1)path：图片所在路径 (2)decodestyle：图片的解码方式。(‘r’：UTF-8编码； ‘rb’：非UTF-8编码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 附上代码# 图像大小调整import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltimport cv2 as cvtf.compat.v1.disable_eager_execution()imgpath2 = &quot;/home/tlooh/下载/Data/tmp/2.jpeg&quot;def resize_img(imgpath,target_size): img_raw_data = tf.io.gfile.GFile(imgpath2,'rb').read() with tf.compat.v1.Session() as sess: # 将图像使用JPEG的格式解码从而得到图像对应的三维矩阵 # TensorFlow提供了 tf.image.decode_png 函数对png格式的图像进行解码 # 解码之后的结果为一个张量，在使用它的取值之前需要明确调用运行的过程 img_data = tf.image.decode_jpeg(img_raw_data)# img_data.set_shape([600,600,3])# print(img_data.shape.as_list()) # 通过tf.image.resize_images函数调整图像的大小 # 这个函数第一个参数为原始图像，第二个和第三个参数为调整后图像的大小 # antialias 参数给出了调整图像大小的算法 resized = tf.image.resize(img_data, target_size, antialias=True) # 输出调整后图像的大小，此处的结果为（300， 300， ？）表示图像的大小为300*300 # 但是在图像的深度还没有明确设置之前会是问号 # TensorFlow的函数处理图片后存储的数据是float32格式的， # 需要转换成uint8才能正确打印图片。 resized_photo = np.asarray(resized.eval(), dtype='uint8') plt.imshow(resized_photo) plt.show() # 通道转换 resized_photo = cv.cvtColor(resized_photo,cv.COLOR_BGR2RGB) img_show(&quot;resized&quot;,resized_photo) resize_img(imgpath2,[600,600]) (1) 报错 AttributeError: module ‘tensorflow’ has no attribute ‘gfile’ 原因与解决方案然后百度，发现是说问题产生的原因：在当前的版本中，gfile已经定义在io包的file_io.py中。 1img_raw_data = tf.gfile.FastGFile(imgpath2,'rb').read() 于是改为 1img_raw_data = tf.io.gfile.FastGFile(imgpath2,'rb').read() 仍然报错 然后查阅官方文档才发现，调用形式发生变化，这里附上官方文档地址：TensorFlow-Python 文档 1img_raw_data = tf.io.gfile.GFile(imgpath2,'rb').read() 至此，问题解决 (2) 报错 AttributeError: module ‘tensorflow._api.v2.image’ has no attribute ‘resize_images’ 原因应该如先前一样，版本高了，函数发生了变化： 代码如下，问题解决！ 12# 双线性插值 resized = tf.image.resize(img_data, target_size, antialias='bilinear') (3) plt.imshow() 和 cv.imshow() 展示的图片不一样？问题如下，img_show() 是我自己封装的cv展示函数 原理很简单： opencv的是按照B、G、R 三个通道读取图片； matplotlib.pyplot 则是R、G、B模式，也就是说opencv有点特别 所以我们需要用函数 cv.cvtColor( xxx , cv.COLOR_BGR2RGB) # CV BGR转变RGB 1234567plt.imshow(resized_photo)plt.show() # 通道转换 resized_photo = cv.cvtColor(resized_photo,cv.COLOR_BGR2RGB) img_show(resized_photo) 问题解决！！","link":"/2022/03/05/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"杂项","slug":"杂项","link":"/tags/%E6%9D%82%E9%A1%B9/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"复试参考","slug":"复试参考","link":"/tags/%E5%A4%8D%E8%AF%95%E5%8F%82%E8%80%83/"},{"name":"统计学习","slug":"统计学习","link":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"},{"name":"复试","slug":"复试","link":"/tags/%E5%A4%8D%E8%AF%95/"}],"categories":[{"name":"人工智能","slug":"人工智能","link":"/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"研究生","slug":"研究生","link":"/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/categories/Deep-Learning/"},{"name":"数字图像处理","slug":"数字图像处理","link":"/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]}